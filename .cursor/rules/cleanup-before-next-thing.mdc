# Clean Up Your Mess Before Moving to Next Thing

## ðŸŽ¯ Core Principle
**ALWAYS clean up your mess before moving to the next thing, unless you have to pee or something.**

## ðŸ“‹ Rule Requirements

### Before Starting New Work:
1. **Check current state** - What mess exists?
2. **Assess mess size** - Is it manageable or nuclear?
3. **Choose cleanup strategy** - Fix or reset?
4. **Execute cleanup** - Complete the cleanup
5. **Verify clean state** - Confirm everything is working
6. **Check branch status** - Ensure using appropriate branch for new work

### Mess Assessment Criteria:
- **Small mess** (< 10 files): Fix manually
- **Medium mess** (10-50 files): Use automated tools
- **Large mess** (50+ files): Nuclear option (git reset --hard)
- **Critical mess** (breaking functionality): Immediate nuclear option

## ðŸ§¹ Cleanup Strategies

### Strategy 1: Manual Fix (Small Mess)
```bash
# Fix specific issues
uv run ruff check --fix
uv run black src/
git add -A && git commit -m "ðŸ”§ Fix specific issues"
```

### Strategy 2: Automated Tools (Medium Mess)
```bash
# Use existing fix scripts
uv run python fix_flake8_issues.py
uv run python fix_type_annotations.py
git add -A && git commit -m "ðŸ”§ Apply automated fixes"
```

### Strategy 3: Nuclear Option (Large Mess)
```bash
# Reset everything to clean state
git reset --hard HEAD
git clean -fd
# Verify clean state
git status
```

### Strategy 4: Emergency Nuclear (Critical Mess)
```bash
# Immediate reset if functionality broken
git reset --hard HEAD
git clean -fd
# Test core functionality
uv run python src/ghostbusters/enhanced_ghostbusters.py
```

## ðŸŽ¯ Success Criteria

### Clean State Requirements:
- **Working tree clean** - No uncommitted changes
- **Core functionality working** - Ghostbusters runs successfully
- **No critical errors** - Syntax errors fixed
- **Ready for next thing** - Can proceed safely

### Quality Gates:
- **Git status clean** - No modified files
- **Tests passing** - Core functionality verified
- **Confidence high** - System working well
- **No technical debt** - Issues resolved

## ðŸš¨ Exception Cases

### Emergency Exceptions:
- **Bathroom emergency** - Pee first, clean later
- **Fire in building** - Evacuate immediately
- **System down** - Fix critical issues first
- **Security breach** - Address immediately

### Temporary Exceptions:
- **Research phase** - Exploring new approaches
- **Prototype development** - Rapid iteration
- **Debugging session** - Temporary mess allowed
- **Learning experiment** - Controlled chaos

## ðŸ“Š Mess Prevention

### Best Practices:
1. **Commit frequently** - Don't let mess accumulate
2. **Use branches** - Isolate experimental work
3. **Test regularly** - Catch issues early
4. **Monitor state** - Keep track of changes
5. **Check branch history** - Verify branch hasn't been merged already
6. **Create new branches** - Use descriptive branch names for new features

### Warning Signs:
- **Many modified files** - > 20 files changed
- **Linter errors** - > 50 errors
- **Syntax errors** - Any syntax errors
- **Broken functionality** - Core features not working
- **Wrong branch usage** - Using branch with merged PRs
- **Branch name mismatch** - Branch name doesn't match work being done

## ðŸŒ¿ Branch Management

### Before Using Any Branch:
1. **Check branch status** - `git branch -a`
2. **Check PR history** - `gh pr list --state all | grep <branch-name>`
3. **Verify branch state** - Ensure branch hasn't been merged already
4. **Check remote sync** - `git status` to see if up to date

### Branch Selection Rules:
- **Never reuse merged branches** - If PR exists and is merged, create new branch
- **Use descriptive names** - `feature/ide-performance-optimization` not `feature/old-branch`
- **Check branch purpose** - Ensure branch name matches intended work
- **Verify clean state** - Branch should be clean before adding new work

### New Branch Creation:
```bash
# Check current branch status
git status
git branch -a

# Check if branch has existing PRs
gh pr list --state all | grep <branch-name>

# If branch is clean and appropriate, use it
# If branch has merged PRs or wrong purpose, create new branch
git checkout -b feature/new-descriptive-name

# Verify new branch
git status
git branch
```

### Branch Cleanup:
```bash
# If accidentally used wrong branch, fix immediately
git checkout -b feature/correct-branch-name
git push -u origin feature/correct-branch-name

# Clean up old branch
git checkout <old-branch>
git reset --hard HEAD~1  # Remove last commit
git push --force-with-lease origin <old-branch>

# Switch back to correct branch
git checkout feature/correct-branch-name
```

### Common Mistakes to Avoid:
- **Using merged branches** - Always check PR history before using existing branches
- **Reusing old branch names** - Create new descriptive branches for new work
- **Not checking branch purpose** - Ensure branch name matches the work being done
- **Forgetting to clean up** - Always fix branch mistakes immediately

### Example Mistake (What NOT to do):
```bash
# WRONG: Using a branch that already has a merged PR
git checkout feature/diversity-hypothesis-validation  # This branch already merged!
git add -A && git commit -m "New feature"  # Adding to wrong branch

# RIGHT: Check first, then create new branch
gh pr list --state all | grep diversity-hypothesis-validation  # Check if merged
git checkout -b feature/ide-performance-optimization  # Create new branch
git add -A && git commit -m "New feature"  # Add to correct branch
```

## ðŸŽ¯ Implementation
### Before Each New Task:
```python
def check_clean_state():
    """Check if we're in a clean state before proceeding"""
    git_status = run_git_status()
    if git_status.modified_files > 10:
        print("âš ï¸  Mess detected! Clean up first!")
        return False
    return True

def cleanup_if_needed():
    """Clean up mess if present"""
    if not check_clean_state():
        if mess_size > 50:
            nuclear_cleanup()
        else:
            manual_cleanup()
```

### Integration Points:
- **Before new features** - Check clean state
- **Before major changes** - Verify no mess
- **Before commits** - Ensure quality
- **Before pushing** - Confirm clean

## ðŸŽ¯ Rule Enforcement

### Automatic Checks:
- **Pre-commit hooks** - Prevent messy commits
- **CI/CD validation** - Catch issues early
- **Regular audits** - Monitor code quality
- **Automated testing** - Verify functionality

### Manual Checks:
- **Before starting work** - Assess current state
- **During development** - Monitor mess accumulation
- **Before switching tasks** - Clean up current work
- **Before ending session** - Leave clean state

## ðŸ“‹ Rule Validation

### Success Metrics:
- **Clean git status** - No uncommitted changes
- **High confidence** - > 95% system confidence
- **No critical errors** - Zero syntax errors
- **Ready for next thing** - Can proceed safely

### Failure Indicators:
- **Many modified files** - Mess accumulation
- **Low confidence** - System issues
- **Critical errors** - Broken functionality
- **Unable to proceed** - Blocked by mess

---

**Remember: Clean up your mess before moving to the next thing, unless you have to pee or something! ðŸ§¹**
description:
globs:
alwaysApply: false
---
