{
  "file_models": {
    "fix_test_rule_compliance_indentation.py": {
      "file_path": "fix_test_rule_compliance_indentation.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 64,
      "line_count": 103,
      "function_count": 2,
      "class_count": 0,
      "import_count": 2,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Fix indentation issues in test_rule_compliance.py",
          "Fix indentation issues in test_rule_compliance.py",
          "Fix the test file"
        ],
        "imports": [
          "ast",
          "pathlib.Path"
        ],
        "functions": [
          {
            "name": "fix_test_rule_compliance_indentation",
            "docstring": "Fix indentation issues in test_rule_compliance.py"
          },
          {
            "name": "main",
            "docstring": "Fix the test file"
          }
        ],
        "classes": [],
        "variables": [],
        "line_count": 103
      }
    },
    "final_syntax_fix.py": {
      "file_path": "final_syntax_fix.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 134,
      "line_count": 194,
      "function_count": 7,
      "class_count": 1,
      "import_count": 5,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Final Syntax Fixer\nComprehensive fixer for all remaining syntax issues",
          "Final comprehensive syntax fixer",
          "Test the final syntax fixer",
          "Fix all syntax issues in a file",
          "Apply comprehensive syntax fixes",
          "Check if we're inside a function or class definition",
          "Validate that the fix produces valid Python",
          "Fix multiple files",
          "Save fixed content to file"
        ],
        "imports": [
          "re",
          "ast",
          "pathlib.Path",
          "typing.List",
          "typing.Dict",
          "shutil"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Test the final syntax fixer"
          },
          {
            "name": "fix_file",
            "docstring": "Fix all syntax issues in a file"
          },
          {
            "name": "apply_comprehensive_fixes",
            "docstring": "Apply comprehensive syntax fixes"
          },
          {
            "name": "is_in_function_context",
            "docstring": "Check if we're inside a function or class definition"
          },
          {
            "name": "validate_fix",
            "docstring": "Validate that the fix produces valid Python"
          },
          {
            "name": "fix_multiple_files",
            "docstring": "Fix multiple files"
          },
          {
            "name": "save_fixed_file",
            "docstring": "Save fixed content to file"
          }
        ],
        "classes": [
          {
            "name": "FinalSyntaxFixer",
            "docstring": "Final comprehensive syntax fixer"
          }
        ],
        "variables": [],
        "line_count": 194
      }
    },
    "fix_test_rule_compliance.py": {
      "file_path": "fix_test_rule_compliance.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 67,
      "line_count": 108,
      "function_count": 2,
      "class_count": 0,
      "import_count": 2,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Fix indentation issues in test_rule_compliance_enforcement.py",
          "Fix indentation issues in test files",
          "Fix the test file"
        ],
        "imports": [
          "ast",
          "pathlib.Path"
        ],
        "functions": [
          {
            "name": "fix_test_file_indentation",
            "docstring": "Fix indentation issues in test files"
          },
          {
            "name": "main",
            "docstring": "Fix the test file"
          }
        ],
        "classes": [],
        "variables": [],
        "line_count": 108
      }
    },
    "fix_remaining_indentation.py": {
      "file_path": "fix_remaining_indentation.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 144,
      "line_count": 200,
      "function_count": 7,
      "class_count": 0,
      "import_count": 3,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Fix the remaining indentation errors identified by flake8",
          "Fix specific indentation errors in a file",
          "Check if line is after a function definition",
          "Check if line is after a control flow statement",
          "Check if line is after a block start",
          "Check if a line needs indentation fix",
          "Find all Python files in the project",
          "Fix remaining indentation errors"
        ],
        "imports": [
          "subprocess",
          "pathlib.Path",
          "typing.List"
        ],
        "functions": [
          {
            "name": "fix_specific_indentation_errors",
            "docstring": "Fix specific indentation errors in a file"
          },
          {
            "name": "is_after_function_definition",
            "docstring": "Check if line is after a function definition"
          },
          {
            "name": "is_after_control_flow",
            "docstring": "Check if line is after a control flow statement"
          },
          {
            "name": "is_after_block_start",
            "docstring": "Check if line is after a block start"
          },
          {
            "name": "needs_indentation_fix",
            "docstring": "Check if a line needs indentation fix"
          },
          {
            "name": "find_python_files",
            "docstring": "Find all Python files in the project"
          },
          {
            "name": "main",
            "docstring": "Fix remaining indentation errors"
          }
        ],
        "classes": [],
        "variables": [],
        "line_count": 200
      }
    },
    "ast_projection_demo.py": {
      "file_path": "ast_projection_demo.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 293,
      "line_count": 364,
      "function_count": 16,
      "class_count": 1,
      "import_count": 4,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "AST Projection Demo\nShows how bridging model gaps could help project/reconstruct broken Python code",
          "Demo of how AST-based projection could reconstruct broken code",
          "Run the AST projection demo",
          "Demonstrate how AST projection could work",
          "Demonstrate function signature projection",
          "Demonstrate class structure projection",
          "Demonstrate import structure projection",
          "Demonstrate expression structure projection",
          "Project complete function signature from broken fragment",
          "Project complete class structure from broken fragment",
          "Project complete import structure from broken fragment",
          "Project complete expression structure from broken fragment",
          "Show what AST analysis could provide for function projection",
          "Show what AST analysis could provide for class projection",
          "Show what AST analysis could provide for import projection",
          "Show what AST analysis could provide for expression projection",
          "Generate comprehensive projection capabilities report"
        ],
        "imports": [
          "ast",
          "re",
          "pathlib.Path",
          "typing.Dict",
          "typing.List",
          "typing.Any",
          "typing.Optional",
          "typing.Tuple"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Run the AST projection demo"
          },
          {
            "name": "__init__",
            "docstring": null
          },
          {
            "name": "demonstrate_projection_capabilities",
            "docstring": "Demonstrate how AST projection could work"
          },
          {
            "name": "_demo_function_projection",
            "docstring": "Demonstrate function signature projection"
          },
          {
            "name": "_demo_class_projection",
            "docstring": "Demonstrate class structure projection"
          },
          {
            "name": "_demo_import_projection",
            "docstring": "Demonstrate import structure projection"
          },
          {
            "name": "_demo_expression_projection",
            "docstring": "Demonstrate expression structure projection"
          },
          {
            "name": "_project_function_signature",
            "docstring": "Project complete function signature from broken fragment"
          },
          {
            "name": "_project_class_structure",
            "docstring": "Project complete class structure from broken fragment"
          },
          {
            "name": "_project_import_structure",
            "docstring": "Project complete import structure from broken fragment"
          },
          {
            "name": "_project_expression_structure",
            "docstring": "Project complete expression structure from broken fragment"
          },
          {
            "name": "_analyze_function_ast_insights",
            "docstring": "Show what AST analysis could provide for function projection"
          },
          {
            "name": "_analyze_class_ast_insights",
            "docstring": "Show what AST analysis could provide for class projection"
          },
          {
            "name": "_analyze_import_ast_insights",
            "docstring": "Show what AST analysis could provide for import projection"
          },
          {
            "name": "_analyze_expression_ast_insights",
            "docstring": "Show what AST analysis could provide for expression projection"
          },
          {
            "name": "_generate_projection_report",
            "docstring": "Generate comprehensive projection capabilities report"
          }
        ],
        "classes": [
          {
            "name": "ASTProjectionDemo",
            "docstring": "Demo of how AST-based projection could reconstruct broken code"
          }
        ],
        "variables": [],
        "line_count": 364
      }
    },
    "test_git_enhanced.py": {
      "file_path": "test_git_enhanced.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 42,
      "line_count": 62,
      "function_count": 1,
      "class_count": 0,
      "import_count": 4,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Test Git-Enhanced AST Fixer\nDemonstrates the Git-enhanced approach with files that have Git history",
          "Test the Git-enhanced AST fixer with files that have Git history"
        ],
        "imports": [
          "git_enhanced_ast_fixer.GitEnhancedASTFixer",
          "pathlib.Path",
          "subprocess",
          "ast"
        ],
        "functions": [
          {
            "name": "test_git_enhanced_fixer",
            "docstring": "Test the Git-enhanced AST fixer with files that have Git history"
          }
        ],
        "classes": [],
        "variables": [],
        "line_count": 62
      }
    },
    "multi_generational_git_analyzer.py": {
      "file_path": "multi_generational_git_analyzer.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 428,
      "line_count": 545,
      "function_count": 26,
      "class_count": 2,
      "import_count": 9,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Multi-Generational Git Analyzer\nModels several commits back to understand file evolution and guide reconstruction",
          "Model of a file at a specific commit",
          "Analyzes multiple generations of Git history to understand file evolution",
          "Test the multi-generational Git analyzer",
          "Analyze file evolution across multiple Git generations",
          "Get models for multiple generations of commits",
          "Extract model from AST",
          "Extract basic model from content",
          "Extract functions from AST",
          "Extract classes from AST",
          "Extract imports from AST",
          "Extract variables from AST",
          "Extract decorator name from AST",
          "Extract base class name from AST",
          "Extract class methods from AST",
          "Calculate complexity metrics from AST",
          "Analyze patterns in file evolution",
          "Analyze size evolution trend",
          "Analyze structural evolution trend",
          "Analyze complexity evolution trend",
          "Calculate trend from a list of values",
          "Calculate stability score based on model consistency",
          "Calculate similarity between two models",
          "Identify distinct phases in file evolution",
          "Generate recommendations based on evolution analysis",
          "Create a database of evolution information",
          "Find the most stable generation",
          "Find the best generation to use as a template"
        ],
        "imports": [
          "json",
          "subprocess",
          "ast",
          "tempfile",
          "os",
          "pathlib.Path",
          "typing.Dict",
          "typing.List",
          "typing.Any",
          "typing.Optional",
          "dataclasses.dataclass",
          "dataclasses.asdict",
          "git_enhanced_ast_fixer.GitEnhancedASTFixer"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Test the multi-generational Git analyzer"
          },
          {
            "name": "__init__",
            "docstring": null
          },
          {
            "name": "analyze_file_evolution",
            "docstring": "Analyze file evolution across multiple Git generations"
          },
          {
            "name": "get_commit_models",
            "docstring": "Get models for multiple generations of commits"
          },
          {
            "name": "extract_ast_model",
            "docstring": "Extract model from AST"
          },
          {
            "name": "extract_basic_model",
            "docstring": "Extract basic model from content"
          },
          {
            "name": "extract_functions_from_ast",
            "docstring": "Extract functions from AST"
          },
          {
            "name": "extract_classes_from_ast",
            "docstring": "Extract classes from AST"
          },
          {
            "name": "extract_imports_from_ast",
            "docstring": "Extract imports from AST"
          },
          {
            "name": "extract_variables_from_ast",
            "docstring": "Extract variables from AST"
          },
          {
            "name": "extract_decorator",
            "docstring": "Extract decorator name from AST"
          },
          {
            "name": "extract_base",
            "docstring": "Extract base class name from AST"
          },
          {
            "name": "extract_class_methods",
            "docstring": "Extract class methods from AST"
          },
          {
            "name": "calculate_complexity_metrics",
            "docstring": "Calculate complexity metrics from AST"
          },
          {
            "name": "analyze_evolution_patterns",
            "docstring": "Analyze patterns in file evolution"
          },
          {
            "name": "analyze_size_trend",
            "docstring": "Analyze size evolution trend"
          },
          {
            "name": "analyze_structure_trend",
            "docstring": "Analyze structural evolution trend"
          },
          {
            "name": "analyze_complexity_trend",
            "docstring": "Analyze complexity evolution trend"
          },
          {
            "name": "calculate_trend",
            "docstring": "Calculate trend from a list of values"
          },
          {
            "name": "calculate_stability_score",
            "docstring": "Calculate stability score based on model consistency"
          },
          {
            "name": "calculate_model_similarity",
            "docstring": "Calculate similarity between two models"
          },
          {
            "name": "identify_evolution_phases",
            "docstring": "Identify distinct phases in file evolution"
          },
          {
            "name": "generate_evolution_recommendations",
            "docstring": "Generate recommendations based on evolution analysis"
          },
          {
            "name": "create_evolution_database",
            "docstring": "Create a database of evolution information"
          },
          {
            "name": "find_most_stable_generation",
            "docstring": "Find the most stable generation"
          },
          {
            "name": "find_best_template_generation",
            "docstring": "Find the best generation to use as a template"
          }
        ],
        "classes": [
          {
            "name": "CommitModel",
            "docstring": "Model of a file at a specific commit"
          },
          {
            "name": "MultiGenerationalGitAnalyzer",
            "docstring": "Analyzes multiple generations of Git history to understand file evolution"
          }
        ],
        "variables": [],
        "line_count": 545
      }
    },
    "ast_model_gap_analyzer.py": {
      "file_path": "ast_model_gap_analyzer.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 352,
      "line_count": 388,
      "function_count": 7,
      "class_count": 1,
      "import_count": 4,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "AST Model Gap Analyzer\nIdentifies what AST models that we don't have, and how bridging the gap could help",
          "Analyzer that identifies AST modeling capabilities we're missing",
          "Run the AST model gap analyzer",
          "Analyze what AST models that we don't have",
          "Identify what we currently model in our syntax fixing approach",
          "Identify what AST can model that we don't",
          "Identify the gaps between current models and AST models",
          "Generate comprehensive gap analysis report"
        ],
        "imports": [
          "ast",
          "json",
          "pathlib.Path",
          "typing.Dict",
          "typing.List",
          "typing.Any",
          "typing.Set",
          "typing.Optional"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Run the AST model gap analyzer"
          },
          {
            "name": "__init__",
            "docstring": null
          },
          {
            "name": "analyze_model_gaps",
            "docstring": "Analyze what AST models that we don't have"
          },
          {
            "name": "_identify_current_models",
            "docstring": "Identify what we currently model in our syntax fixing approach"
          },
          {
            "name": "_identify_ast_models",
            "docstring": "Identify what AST can model that we don't"
          },
          {
            "name": "_identify_model_gaps",
            "docstring": "Identify the gaps between current models and AST models"
          },
          {
            "name": "_generate_gap_report",
            "docstring": "Generate comprehensive gap analysis report"
          }
        ],
        "classes": [
          {
            "name": "ASTModelGapAnalyzer",
            "docstring": "Analyzer that identifies AST modeling capabilities we're missing"
          }
        ],
        "variables": [],
        "line_count": 388
      }
    },
    "model_sufficiency_analyzer.py": {
      "file_path": "model_sufficiency_analyzer.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 377,
      "line_count": 417,
      "function_count": 11,
      "class_count": 1,
      "import_count": 3,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "Model Sufficiency Analyzer\nAnalyzes if our current models have sufficient information to determine requirements and recreate code",
          "Analyzer that determines if our models are sufficient for requirements and recreation",
          "Run the model sufficiency analyzer",
          "Analyze if our models are sufficient for requirements and recreation",
          "Define what models we currently have",
          "Analyze if our models can determine requirements",
          "Analyze if our models can recreate code",
          "Generate comprehensive sufficiency analysis report",
          "Calculate overall requirements determination score",
          "Calculate overall code recreation score",
          "Assess if requirements determination is sufficient",
          "Assess if code recreation is sufficient"
        ],
        "imports": [
          "json",
          "pathlib.Path",
          "typing.Dict",
          "typing.List",
          "typing.Any",
          "typing.Set"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Run the model sufficiency analyzer"
          },
          {
            "name": "__init__",
            "docstring": null
          },
          {
            "name": "analyze_model_sufficiency",
            "docstring": "Analyze if our models are sufficient for requirements and recreation"
          },
          {
            "name": "_define_current_models",
            "docstring": "Define what models we currently have"
          },
          {
            "name": "_analyze_requirements_capabilities",
            "docstring": "Analyze if our models can determine requirements"
          },
          {
            "name": "_analyze_recreation_capabilities",
            "docstring": "Analyze if our models can recreate code"
          },
          {
            "name": "_generate_sufficiency_report",
            "docstring": "Generate comprehensive sufficiency analysis report"
          },
          {
            "name": "_calculate_requirements_score",
            "docstring": "Calculate overall requirements determination score"
          },
          {
            "name": "_calculate_recreation_score",
            "docstring": "Calculate overall code recreation score"
          },
          {
            "name": "_assess_requirements_sufficiency",
            "docstring": "Assess if requirements determination is sufficient"
          },
          {
            "name": "_assess_recreation_sufficiency",
            "docstring": "Assess if code recreation is sufficient"
          }
        ],
        "classes": [
          {
            "name": "ModelSufficiencyAnalyzer",
            "docstring": "Analyzer that determines if our models are sufficient for requirements and recreation"
          }
        ],
        "variables": [],
        "line_count": 417
      }
    },
    "ast_capability_analyzer.py": {
      "file_path": "ast_capability_analyzer.py",
      "file_type": "python",
      "model_type": "ast",
      "complexity_score": 383,
      "line_count": 452,
      "function_count": 26,
      "class_count": 1,
      "import_count": 4,
      "error_count": 0,
      "model_data": {
        "docstrings": [
          "AST Capability Analyzer\nDemonstrates how AST can enhance Python project modeling",
          "Analyzer that demonstrates AST capabilities for project modeling",
          "Run the AST capability analyzer",
          "Analyze what AST can tell us about Python projects",
          "Find Python files in our project (excluding .venv)",
          "Analyze what AST can extract from a file",
          "Extract comprehensive insights using AST",
          "Extract imports using AST - much more accurate than regex",
          "Extract functions using AST - complete function analysis",
          "Extract classes using AST - complete class analysis",
          "Extract dependencies using AST - accurate dependency tracking",
          "Calculate complexity using AST - precise metrics",
          "Analyze code structure using AST",
          "Detect code patterns using AST",
          "Calculate comprehensive metrics using AST",
          "Extract function arguments using AST",
          "Extract decorator information using AST",
          "Extract base class information using AST",
          "Extract keyword arguments using AST",
          "Extract expression information using AST",
          "Extract class methods using AST",
          "Extract return type using AST",
          "Extract type annotation using AST",
          "Calculate function complexity using AST",
          "Record files that AST cannot parse",
          "Generate comprehensive AST capability report",
          "Calculate average complexity metrics"
        ],
        "imports": [
          "ast",
          "json",
          "pathlib.Path",
          "typing.Dict",
          "typing.List",
          "typing.Any",
          "typing.Set"
        ],
        "functions": [
          {
            "name": "main",
            "docstring": "Run the AST capability analyzer"
          },
          {
            "name": "__init__",
            "docstring": null
          },
          {
            "name": "analyze_ast_capabilities",
            "docstring": "Analyze what AST can tell us about Python projects"
          },
          {
            "name": "_find_project_files",
            "docstring": "Find Python files in our project (excluding .venv)"
          },
          {
            "name": "_analyze_file_capabilities",
            "docstring": "Analyze what AST can extract from a file"
          },
          {
            "name": "_extract_ast_insights",
            "docstring": "Extract comprehensive insights using AST"
          },
          {
            "name": "_extract_imports_ast",
            "docstring": "Extract imports using AST - much more accurate than regex"
          },
          {
            "name": "_extract_functions_ast",
            "docstring": "Extract functions using AST - complete function analysis"
          },
          {
            "name": "_extract_classes_ast",
            "docstring": "Extract classes using AST - complete class analysis"
          },
          {
            "name": "_extract_dependencies_ast",
            "docstring": "Extract dependencies using AST - accurate dependency tracking"
          },
          {
            "name": "_calculate_complexity_ast",
            "docstring": "Calculate complexity using AST - precise metrics"
          },
          {
            "name": "_analyze_structure_ast",
            "docstring": "Analyze code structure using AST"
          },
          {
            "name": "_detect_patterns_ast",
            "docstring": "Detect code patterns using AST"
          },
          {
            "name": "_calculate_metrics_ast",
            "docstring": "Calculate comprehensive metrics using AST"
          },
          {
            "name": "_extract_function_args_ast",
            "docstring": "Extract function arguments using AST"
          },
          {
            "name": "_extract_decorator_ast",
            "docstring": "Extract decorator information using AST"
          },
          {
            "name": "_extract_base_ast",
            "docstring": "Extract base class information using AST"
          },
          {
            "name": "_extract_keyword_ast",
            "docstring": "Extract keyword arguments using AST"
          },
          {
            "name": "_extract_expression_ast",
            "docstring": "Extract expression information using AST"
          },
          {
            "name": "_extract_class_methods_ast",
            "docstring": "Extract class methods using AST"
          },
          {
            "name": "_extract_return_type_ast",
            "docstring": "Extract return type using AST"
          },
          {
            "name": "_extract_annotation_ast",
            "docstring": "Extract type annotation using AST"
          },
          {
            "name": "_calculate_function_complexity_ast",
            "docstring": "Calculate function complexity using AST"
          },
          {
            "name": "_record_syntax_error",
            "docstring": "Record files that AST cannot parse"
          },
          {
            "name": "_generate_capability_report",
            "docstring": "Generate comprehensive AST capability report"
          },
          {
            "name": "_calculate_avg_complexity",
            "docstring": "Calculate average complexity metrics"
          }
        ],
        "classes": [
          {
            "name": "ASTCapabilityAnalyzer",
            "docstring": "Analyzer that demonstrates AST capabilities for project modeling"
          }
        ],
        "variables": [],
        "line_count": 452
      }
    }
  },
  "summary": {
    "total_files": 10,
    "valid_files": 10,
    "error_files": 0,
    "model_type_counts": {
      "ast": 10
    }
  },
  "metadata": {
    "last_updated": "2025-08-02T18:25:27.551783",
    "checkpoint_count": 0,
    "version": "1.0"
  }
}