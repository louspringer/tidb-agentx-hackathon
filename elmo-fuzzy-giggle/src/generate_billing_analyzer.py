#!/usr/bin/env python3
"""
Structured Generator for Gemini Billing Analyzer
Uses deterministic code generation system to create linting-compliant code
"""

from pathlib import Path

from code_generator import (
    ClassDefinition,
    CodeFile,
    CodeGenerator,
    FunctionDefinition,
    ImportStatement,
)


def generate_gemini_billing_analyzer() -> CodeFile:
    """Generate the Gemini billing analyzer using structured models"""

    # Imports
    imports = [
        ImportStatement("asyncio"),
        ImportStatement("json"),
        ImportStatement("logging"),
        ImportStatement("os"),
        ImportStatement("subprocess"),
        ImportStatement("uuid"),
        ImportStatement("datetime", ["datetime", "timezone"], is_from=True),
        ImportStatement("typing", ["Any", "Dict", "Optional"], is_from=True),
        ImportStatement(
            "langchain_google_genai",
            ["ChatGoogleGenerativeAI"],
            is_from=True,
        ),
        ImportStatement("langchain_core.messages", ["HumanMessage"], is_from=True),
    ]

    # GeminiBillingAnalyzer class
    setup_method = FunctionDefinition(
        name="__init__",
        parameters=["self"],
        return_type="None",
        docstring="Initialize the Gemini billing analyzer",
        body=[
            "# Configure logging",
            "logging.basicConfig(level=logging.INFO)",
            "self.logger = logging.getLogger(__name__)",
            "",
            "self.llm = self._setup_gemini_llm()",
        ],
    )

    setup_llm_method = FunctionDefinition(
        name="_setup_gemini_llm",
        parameters=["self"],
        return_type="Optional[ChatGoogleGenerativeAI]",
        docstring="Setup Gemini LLM with proper API key",
        body=[
            "try:",
            "    # Try to get API key from environment",
            "    api_key = os.getenv('GOOGLE_API_KEY') or os.getenv('GEMINI_API_KEY')",
            "",
            "    if not api_key:",
            "        # Try to get from gcloud (this might not work for Gemini API)",
            "        result = subprocess.run(",
            "            ['gcloud', 'auth', 'print-access-token'],",
            "            capture_output=True,",
            "            text=True,",
            "            check=True",
            "        )",
            "        api_key = result.stdout.strip()",
            "        self.logger.info('Using Google Cloud access token for Gemini')",
            "",
            "    if api_key:",
            "        llm = ChatGoogleGenerativeAI(",
            "            model='gemini-1.5-flash',",
            "            google_api_key=api_key,",
            "            temperature=0.1",
            "        )",
            "        self.logger.info('‚úÖ Gemini LLM initialized successfully')",
            "        return llm",
            "    else:",
            "        self.logger.warning('‚ùå No API key found for Gemini')",
            "        return None",
            "",
            "except Exception as e:",
            "    self.logger.error(f'‚ùå Error setting up Gemini LLM: {e}')",
            "    return None",
        ],
    )

    get_billing_method = FunctionDefinition(
        name="get_billing_data",
        parameters=["self"],
        return_type="Dict[str, Any]",
        docstring="Get current GCP billing data",
        body=[
            "try:",
            "    # Get project info",
            "    result = subprocess.run(",
            "        ['gcloud', 'config', 'get-value', 'project'],",
            "        capture_output=True,",
            "        text=True,",
            "        check=True",
            "    )",
            "    project_id = result.stdout.strip()",
            "",
            "    # Get billing account",
            "    result = subprocess.run(",
            "        ['gcloud', 'billing', 'accounts', 'list', '--format=value(name)'],",
            "        capture_output=True,",
            "        text=True,",
            "        check=True",
            "    )",
            "    billing_account = result.stdout.strip().split('\\n')[0] if result.stdout.strip() else None",
            "",
            "    # Get enabled services",
            "    result = subprocess.run(",
            "        ['gcloud', 'services', 'list', '--enabled', '--format=value(name)'],",
            "        capture_output=True,",
            "        text=True,",
            "        check=True",
            "    )",
            "    enabled_services = result.stdout.strip().split('\\n') if result.stdout.strip() else []",
            "",
            "    # Get resource usage",
            "    resources = {}",
            "",
            "    # Cloud Functions",
            "    try:",
            "        result = subprocess.run(",
            "            ['gcloud', 'functions', 'list', '--format=value(name)'],",
            "            capture_output=True,",
            "            text=True,",
            "            check=True",
            "        )",
            "        functions = result.stdout.strip().split('\\n') if result.stdout.strip() else []",
            "        resources['cloud_functions'] = len(functions)",
            "    except Exception:",
            "        resources['cloud_functions'] = 0",
            "",
            "    # Cloud Run",
            "    try:",
            "        result = subprocess.run(",
            "            ['gcloud', 'run', 'services', 'list', '--format=value(name)'],",
            "            capture_output=True,",
            "            text=True,",
            "            check=True",
            "        )",
            "        run_services = result.stdout.strip().split('\\n') if result.stdout.strip() else []",
            "        resources['cloud_run'] = len(run_services)",
            "    except Exception:",
            "        resources['cloud_run'] = 0",
            "",
            "    # Firestore",
            "    try:",
            "        result = subprocess.run(",
            "            ['gcloud', 'firestore', 'databases', 'list', '--format=value(name)'],",
            "            capture_output=True,",
            "            text=True,",
            "            check=True",
            "        )",
            "        databases = result.stdout.strip().split('\\n') if result.stdout.strip() else []",
            "        resources['firestore'] = len(databases)",
            "    except Exception:",
            "        resources['firestore'] = 0",
            "",
            "    return {",
            "        'project_id': project_id,",
            "        'billing_account': billing_account,",
            "        'enabled_services': enabled_services,",
            "        'resources': resources,",
            "        'timestamp': datetime.now(timezone.utc).isoformat()",
            "    }",
            "",
            "except Exception as e:",
            "    self.logger.error(f'Error getting billing data: {e}')",
            "    return None",
        ],
    )

    analyze_method = FunctionDefinition(
        name="analyze_billing_with_gemini",
        parameters=["self", "billing_data"],
        return_type="Dict[str, Any]",
        docstring="Analyze billing data using Gemini LLM",
        body=[
            "if not self.llm:",
            "    return {'error': 'Gemini LLM not available'}",
            "",
            "try:",
            "    # Create analysis prompt",
            "    prompt = f'''",
            "    You are a GCP cost optimization expert. Analyze this billing data and provide insights:",
            "",
            "    üìä PROJECT INFO:",
            "    - Project ID: {billing_data.get('project_id', 'Unknown')}",
            "    - Billing Account: {billing_data.get('billing_account', 'Unknown')}",
            "    - Enabled Services: {len(billing_data.get('enabled_services', []))} services",
            "    - Analysis Time: {billing_data.get('timestamp', 'Unknown')}",
            "",
            "    üîß RESOURCE USAGE:",
            "    {json.dumps(billing_data.get('resources', {}), indent=2)}",
            "",
            "    üìã ENABLED SERVICES:",
            "    {json.dumps(billing_data.get('enabled_services', [])[:10], indent=2)}",
            "    {'...' if len(billing_data.get('enabled_services', [])) > 10 else ''}",
            "",
            "    üí∞ COST ANALYSIS REQUEST:",
            "    1. **Cost Drivers**: What are the biggest potential cost drivers in this setup?",
            "    2. **Optimization Opportunities**: What specific optimizations would you recommend?",
            "    3. **Risk Assessment**: Any potential billing surprises or unexpected costs?",
            "    4. **Service Analysis**: Which services are most likely to incur costs?",
            "    5. **Actionable Recommendations**: What specific actions should be taken?",
            "",
            "    Please provide a comprehensive analysis with specific recommendations for cost optimization.",
            "    Focus on practical, actionable insights that can reduce GCP costs.",
            "    '''",
            "",
            "    # Send to Gemini",
            "    response = self.llm.invoke([HumanMessage(content=prompt)])",
            "",
            "    return {",
            "        'gemini_analysis': response.content,",
            "        'billing_data': billing_data,",
            "        'analysis_timestamp': datetime.now(timezone.utc).isoformat()",
            "    }",
            "",
            "except Exception as e:",
            "    self.logger.error(f'Error in Gemini analysis: {e}')",
            "    return {'error': f'Gemini analysis failed: {str(e)}'}",
        ],
    )

    run_ghostbusters_method = FunctionDefinition(
        name="run_ghostbusters_analysis",
        parameters=["self", "project_path"],
        return_type="Dict[str, Any]",
        docstring="Run Ghostbusters analysis on the project",
        body=[
            "try:",
            "    # Import Ghostbusters orchestrator",
            "    from src.ghostbusters.ghostbusters_orchestrator import GhostbustersOrchestrator",
            "",
            "    # Run Ghostbusters analysis",
            "    orchestrator = GhostbustersOrchestrator(project_path)",
            "    result = await orchestrator.run_ghostbusters()",
            "",
            "    return {",
            "        'confidence_score': result.confidence_score,",
            "        'delusions_detected': len(result.delusions),",
            "        'recovery_actions': len(result.recovery_actions),",
            "        'errors': len(result.errors),",
            "        'ghostbusters_result': result",
            "    }",
            "",
            "except Exception as e:",
            "    logger.error(f'Error in Ghostbusters analysis: {e}')",
            "    return {'error': f'Ghostbusters analysis failed: {str(e)}'}",
        ],
        decorators=["async"],
    )

    analyze_project_method = FunctionDefinition(
        name="analyze_project",
        parameters=["self", "project_path"],
        return_type="Dict[str, Any]",
        docstring="Complete analysis combining Ghostbusters with Gemini billing insights",
        body=[
            "analysis_id = str(uuid.uuid4())",
            "",
            "self.logger.info('Starting Gemini-Integrated Ghostbusters Billing Analysis')",
            "self.logger.info(f'Analysis ID: {analysis_id}')",
            "",
            "# Step 1: Get billing data",
            "self.logger.info('üìä Collecting GCP billing data...')",
            "billing_data = self.get_billing_data()",
            "",
            "if not billing_data:",
            "    return {",
            "        'status': 'error',",
            "        'error_message': 'Failed to collect billing data',",
            "    }",
            "",
            "# Step 2: Analyze billing with Gemini",
            "self.logger.info('üîç Analyzing billing data with Gemini...')",
            "gemini_analysis = self.analyze_billing_with_gemini(billing_data)",
            "",
            "# Step 3: Run Ghostbusters analysis",
            "self.logger.info('üëª Running Ghostbusters analysis...')",
            "ghostbusters_result = await self.run_ghostbusters_analysis(project_path)",
            "",
            "# Step 4: Combine results",
            "combined_result = {",
            "    'analysis_id': analysis_id,",
            "    'project_path': project_path,",
            "    'billing_analysis': gemini_analysis,",
            "    'ghostbusters_analysis': ghostbusters_result,",
            "    'timestamp': datetime.now(timezone.utc).isoformat(),",
            "    'status': 'completed'",
            "}",
            "",
            "self.logger.info('‚úÖ Gemini-Integrated Ghostbusters Billing Analysis completed!')",
            "",
            "return {",
            "    'analysis_id': analysis_id,",
            "    'status': 'completed',",
            "    'billing_analysis_available': 'gemini_analysis' in gemini_analysis,",
            "    'ghostbusters_analysis_available': 'error' not in ghostbusters_result,",
            "    'summary': {",
            "        'project_id': billing_data.get('project_id'),",
            "        'enabled_services': len(billing_data.get('enabled_services', [])),",
            "        'resources': billing_data.get('resources', {}),",
            "        'ghostbusters_delusions': ghostbusters_result.get('delusions_detected', 0),",
            "        'ghostbusters_confidence': ghostbusters_result.get('confidence_score', 0)",
            "    },",
            "    'full_analysis': combined_result",
            "}",
        ],
        decorators=["async"],
    )

    # Main class
    gemini_analyzer_class = ClassDefinition(
        name="GeminiBillingAnalyzer",
        docstring="Gemini-integrated billing analyzer for GCP cost optimization",
        attributes=[],
        methods=[
            setup_method,
            setup_llm_method,
            get_billing_method,
            analyze_method,
            run_ghostbusters_method,
            analyze_project_method,
        ],
    )

    # Main function
    main_func = FunctionDefinition(
        name="main",
        parameters=[],
        return_type="None",
        docstring="Main function for testing the Gemini billing analyzer",
        body=[
            "# Configure logging",
            "logging.basicConfig(level=logging.INFO)",
            "logger = logging.getLogger(__name__)",
            "",
            "analyzer = GeminiBillingAnalyzer()",
            "",
            "print('üöÄ Starting Gemini-Integrated Ghostbusters Billing Analysis...')",
            "print('üìä Project: elmo-fuzzy-giggle')",
            'print(f\'ü§ñ Gemini LLM: {"‚úÖ Available" if analyzer.llm else "‚ùå Not available"}\')',
            "",
            "result = await analyzer.analyze_project('.')",
            "",
            "print('\\n' + '='*60)",
            "print('üìã ANALYSIS RESULTS')",
            "print('='*60)",
            "print(f'Status: {result[\"status\"]}')",
            "print(f'Analysis ID: {result[\"analysis_id\"]}')",
            'print(f\'Billing Analysis: {"‚úÖ Available" if result["billing_analysis_available"] else "‚ùå Not available"}\')',
            'print(f\'Ghostbusters Analysis: {"‚úÖ Available" if result["ghostbusters_analysis_available"] else "‚ùå Not available"}\')',
            "",
            "if result['summary']:",
            "    print('\\nüìä Summary:')",
            '    print(f\'  Project ID: {result["summary"]["project_id"]}\')',
            '    print(f\'  Enabled Services: {result["summary"]["enabled_services"]}\')',
            '    print(f\'  Resources: {result["summary"]["resources"]}\')',
            '    print(f\'  Ghostbusters Delusions: {result["summary"]["ghostbusters_delusions"]}\')',
            '    print(f\'  Ghostbusters Confidence: {result["summary"]["ghostbusters_confidence"]}\')',
            "",
            "if result.get('full_analysis', {}).get('billing_analysis', {}).get('gemini_analysis'):",
            "    print('\\nü§ñ Gemini Analysis:')",
            "    print('-' * 40)",
            "    print(result['full_analysis']['billing_analysis']['gemini_analysis'])",
            "",
            "return result",
        ],
        decorators=["async"],
    )

    return CodeFile(
        imports=imports,
        classes=[gemini_analyzer_class],
        functions=[main_func],
        module_docstring="Gemini-Integrated Billing Analyzer for Elmo Fuzzy Giggle\nClean implementation combining Ghostbusters with Gemini LLM for GCP billing insights",
        filename="gemini_billing_analyzer.py",
    )


def main():
    """Generate the Gemini billing analyzer"""
    generator = CodeGenerator()

    print("üöÄ Generating Gemini Billing Analyzer...")

    # Generate the analyzer
    analyzer_file = generate_gemini_billing_analyzer()

    # Write to file
    output_path = Path("src/gemini_billing_analyzer.py")
    success = generator.write_file(analyzer_file, output_path)

    if success:
        print("üéâ Gemini Billing Analyzer generated successfully!")
        print("‚úÖ Ready for testing!")
    else:
        print("‚ùå Generation failed!")


if __name__ == "__main__":
    main()
